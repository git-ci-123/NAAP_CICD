name: Dev Release Management
on:
  workflow_dispatch:
    inputs:
      release:
        description: "Release Path"
        required: true
        type: string
env:

  #REPO AND BRANCHES
  TARGET_REPO: "git-ci-123/NAAP_PROJECT"  # Change to your actual repo.
  PROPERTIES_BRANCH: "dev-properties"     # Branch where property files are stored.
  RELEASE_BRANCH: "releasemanagement"     # Branch where the release folder is stored.
  MANIFEST_BRANCH: "dev-manifest"         # Branch where the manifest files are stored.
  SCRIPT_BRANCH: "dev-script"             # Branch where the DB scripts are stored.

  #DB DETAILS
  LIQUIBASE_COMMAND_URL: ${{ secrets.DB_DEV_URL }}
  
  DB_USER_APPCATALOG: ${{ secrets.APPCATALOG_DEV_USER }}
  DB_PASSWORD_APPCATALOG: ${{ secrets.APPCATALOG_DEV_PASSWD }}
  
  DB_USER_BACATALOG: ${{ secrets.BACATALOG_DEV_USER }}
  DB_PASSWORD_BACATALOG: ${{ secrets.BACATALOG_DEV_PASSWD }}
  
  DB_USER_CA: ${{ secrets.CA_DEV_USER }}
  DB_PASSWORD_CA: ${{ secrets.CA_DEV_PASSWD }}

  DB_USER_CDM: ${{ secrets.CDM_DEV_USER }}
  DB_PASSWORD_CDM: ${{ secrets.CDM_DEV_PASSWD }}

  DB_USER_CIF: ${{ secrets.CIF_DEV_USER }}
  DB_PASSWORD_CIF: ${{ secrets.CIF_DEV_PASSWD }}

  DB_USER_CRDM: ${{ secrets.CRDM_DEV_USER }}
  DB_PASSWORD_CRDM: ${{ secrets.CRDM_DEV_PASSWD }}

  DB_USER_CRF: ${{ secrets.CRF_DEV_USER }}
  DB_PASSWORD_CRF: ${{ secrets.CRF_DEV_PASSWD }}

  DB_USER_CRPT: ${{ secrets.CRPT_DEV_USER }}
  DB_PASSWORD_CRPT: ${{ secrets.CRPT_DEV_PASSWD }}

  DB_USER_GALAXY_SHIELD: ${{ secrets.GALAXY_SHIELD_DEV_USER }}
  DB_PASSWORD_GALAXY_SHIELD: ${{ secrets.GALAXY_SHIELD_DEV_PASSWD }}

  DB_USER_GS_AUDITLOG_REPORT: ${{ secrets.GS_AUDITLOG_REPORT_DEV_USER }}
  DB_PASSWORD_GS_AUDITLOG_REPORT: ${{ secrets.GS_AUDITLOG_REPORT_DEV_PASSWD }}

  

  DB_USER_HISTORYS: ${{ secrets.HISTORYS_DEV_USER }}
  DB_PASSWORD_HISTORYS: ${{ secrets.HISTORYS_DEV_PASSWD }}

  DB_USER_NOTES: ${{ secrets.NOTES_DEV_USER }}
  DB_PASSWORD_NOTES: ${{ secrets.NOTES_DEV_PASSWD }}

  

  


jobs:    
  TaskPlan_Validation:
    runs-on: ubuntu-latest
    outputs:
      iteration: ${{ steps.extract.outputs.ITERATION }}
      imagetag: ${{ steps.extract.outputs.IMAGETAG }}
      db: ${{ steps.extract.outputs.DB }}
      property: ${{ steps.check_properties.outputs.property }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Checkout Project Repository
        uses: actions/checkout@v4
        with:
          repository:  ${{ env.TARGET_REPO }}
          token: ${{ secrets.PAT_TOKEN }}    
          ref: ${{ env.RELEASE_BRANCH }}
          path: 'NAAP_Release'
      
      - name: Validate TaskPlan.txt format
        id: validate
        run: |
          release_folder="${{ github.event.inputs.release }}"
          echo "$release_folder"
          file="NAAP_Release/${release_folder}/TaskPlan.txt"
      
          if [ ! -f "$file" ]; then
            echo "ERROR: TaskPlan.txt file not found at $file"
            exit 1
          fi
      
          get_section() {
            awk -v sec="$1" '
            $0 ~ "\\[" sec "\\]" {flag=1; next}
            /^\[/ {flag=0}
            flag==1 && NF > 0 {print $0}
            ' "$file"
          }
      
          headers=$(grep -oP '^\[\w+\]' "$file" | tr -d '[]' | tr '\n' ',' | sed 's/,$//')
          if [ "$headers" != "IMAGETAG,DB,PROPERTY" ]; then
            echo "ERROR: Sections must be exactly [IMAGETAG], [DB], [PROPERTY] in this order."
            echo "Found sections: $headers"
            exit 1
          fi
      
          image_tag=$(get_section IMAGETAG | sed '/^\s*$/d' | paste -sd "," - | tr -d '\r')
          db_url=$(get_section DB | sed '/^\s*$/d' | paste -sd "," - | tr -d '\r')
          property_file=$(get_section PROPERTY | sed '/^\s*$/d' | paste -sd "," - | tr -d '\r')
      
          echo "IMAGETAGS=$image_tag" >> $GITHUB_ENV
          echo "DB=$db_url" >> $GITHUB_ENV
          echo "PROPERTY=$property_file" >> $GITHUB_ENV
      
          echo "image_tag=$image_tag"
          echo "db_url=$db_url"
          echo "property_file=$property_file"
      
          if [ -z "$image_tag" ]; then
            echo "skip_image=true" >> $GITHUB_OUTPUT
          else
            echo "skip_image=false" >> $GITHUB_OUTPUT
          fi
      
          if [ -z "$db_url" ]; then
            echo "skip_db=true" >> $GITHUB_OUTPUT
          else
            echo "skip_db=false" >> $GITHUB_OUTPUT
          fi
      
          if [ -z "$property_file" ]; then
            echo "skip_property=true" >> $GITHUB_OUTPUT
          else
            echo "skip_property=false" >> $GITHUB_OUTPUT
      
            
            echo "$property_file" | tr ',' '\n' | while read -r prop; do
              prop_path="NAAP_Release/${release_folder}/${prop}"
              if [ ! -f "$prop_path" ]; then
                echo "ERROR: Property file '$prop' not found at expected location: $prop_path"
                exit 1
              fi
            done
          fi
  Property_Deployment:
      
      runs-on: ubuntu-latest

      steps:
        - name: Checkout Target Repository
          uses: actions/checkout@v4
          with:
            repository: ${{ env.TARGET_REPO }}
            ref: ${{ env.PROPERTIES_BRANCH }}
            token: ${{ secrets.PAT_TOKEN }}
  
        - name: Set up Git
          run: |
            git config --global user.name "github-actions[bot]"
            git config --global user.email "github-actions[bot]@users.noreply.github.com"
            
        - name: Fetch and Checkout Release Folder from Target Repo
          run: |
            BASE_PATH="${{ github.event.inputs.release }}"
            RELEASE_BRANCH="${{ env.RELEASE_BRANCH }}"
  
            echo "Fetching release branch: $RELEASE_BRANCH from ${{ env.TARGET_REPO }}"
            git fetch origin "$RELEASE_BRANCH" || { echo "::error::Branch $RELEASE_BRANCH not found!"; exit 1; }
  
            echo "Checking out release folder from branch: $RELEASE_BRANCH"
            git checkout origin/"$RELEASE_BRANCH" -- "$BASE_PATH" || { echo "::error::Release folder not found in $RELEASE_BRANCH!"; exit 1; }
  
            [ -d "$BASE_PATH" ] || { echo "::error::[ERROR] Release folder does not exist: $BASE_PATH"; exit 1; }
  
        - name: Process Property File Changes
          run: |
            BASE_PATH="${{ github.event.inputs.release }}"
            LOG_FILE="property_changes.log"
  
            echo "Processing property file changes from $BASE_PATH..." > "$LOG_FILE"
  
            find "$BASE_PATH" -type f -name "*.properties" | while read -r RELEASE_FILE; do
              FILE_NAME=$(basename "$RELEASE_FILE")  # Get the file name (e.g., "config.properties")
              PROPERTY_FILE="$FILE_NAME"  # Matching file in the properties branch
  
              # If the file does not exist, create a new one
              if [ ! -f "$PROPERTY_FILE" ]; then
                echo "[CREATE] Creating new property file: $PROPERTY_FILE" | tee -a "$LOG_FILE"
                cp "$RELEASE_FILE" "$PROPERTY_FILE"
              fi
  
              TEMP_FILE="${PROPERTY_FILE}.tmp"
              cp "$PROPERTY_FILE" "$TEMP_FILE"
  
              SECTION=""
              while IFS= read -r line; do
                [[ -z "$line" || "$line" =~ ^# ]] && continue
  
                case "$line" in
                  "[ADD]") SECTION="ADD"; continue ;;
                  "[UPDATE]") SECTION="UPDATE"; continue ;;
                  "[REMOVE]") SECTION="REMOVE"; continue ;;
                esac
  
                KEY=$(echo "$line" | cut -d= -f1)
                VALUE=$(echo "$line" | cut -d= -f2-)
  
                case "$SECTION" in
                  "ADD")
                    if grep -q "^$KEY=" "$TEMP_FILE"; then
                      echo "::error::[ERROR] Key '$KEY' already exists in $PROPERTY_FILE, ADD operation failed!" | tee -a "$LOG_FILE"
                      exit 1
                    fi
                    echo "$line" >> "$TEMP_FILE"
                    echo "[ADD] $KEY=$VALUE -> Added to $PROPERTY_FILE" | tee -a "$LOG_FILE"
                    ;;
                  "UPDATE")
                    if grep -q "^$KEY=" "$TEMP_FILE"; then
                      OLD_VALUE=$(grep "^$KEY=" "$TEMP_FILE" | cut -d= -f2-)
                      if [[ "$OLD_VALUE" == "$VALUE" ]]; then
                        echo "::error::[ERROR] Key '$KEY' already has the same value in $PROPERTY_FILE, UPDATE operation failed!" | tee -a "$LOG_FILE"
                        exit 1
                      else
                        sed -i "s|^$KEY=.*|$KEY=$VALUE|" "$TEMP_FILE"
                        echo "[UPDATE] $KEY: '$OLD_VALUE' -> '$VALUE' in $PROPERTY_FILE" | tee -a "$LOG_FILE"
                      fi
                    else
                      echo "::error::[ERROR] Key '$KEY' not found in $PROPERTY_FILE, UPDATE operation failed!" | tee -a "$LOG_FILE"
                      exit 1
                    fi
                    ;;
                  "REMOVE")
                    if grep -q "^$KEY=" "$TEMP_FILE"; then
                      sed -i "/^$KEY=/d" "$TEMP_FILE"
                      echo "[REMOVE] $KEY removed from $PROPERTY_FILE" | tee -a "$LOG_FILE"
                    else
                      echo "::error::[ERROR] Key '$KEY' not found in $PROPERTY_FILE, REMOVE operation failed!" | tee -a "$LOG_FILE"
                      exit 1
                    fi
                    ;;
                esac
              done < "$RELEASE_FILE"
  
              mv "$TEMP_FILE" "$PROPERTY_FILE"
            done
  
        - name: Display Logs
          run: cat property_changes.log
  
        - name: Remove Release Folder Before Commit
          run: |
            BASE_PATH="${{ github.event.inputs.release }}"
            [ -d "$BASE_PATH" ] && git rm -rf --cached "$BASE_PATH" || echo "Folder not tracked, skipping removal"
            rm -rf "$BASE_PATH"
  
        - name: Commit and Push Changes to Target Repo
          run: |
            git add -u
            if git diff --cached --quiet; then
              echo "No changes detected, skipping commit."
              exit 0
            fi
            git commit -m "Updated properties from release folder: ${{ github.event.inputs.release }}"
            git push origin "${{ env.PROPERTIES_BRANCH }}" || { echo "::error::Push failed!"; exit 1; }
